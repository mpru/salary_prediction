import pandas as pd
from sklearn.metrics import root_mean_squared_error, r2_score
import matplotlib.pyplot as plt
import seaborn as sns
import statsmodels.api as sm

def explore_missing(datos):
    """
    Analyzes missing values in a DataFrame and provides statistics.

    Parameters:
    ----------
    datos : pd.DataFrame
        The input DataFrame to analyze.

    Returns:
    -------
    None.
    Prints the following statistics:
        - Number of complete rows (rows without missing values).
        - Proportion of complete rows relative to the total.
        - Proportion of non-missing values relative to the total number of cells.
        - A DataFrame summarizing missing values per column
    """

    # Cantidad de casos completos
    complete_cases = datos.dropna().shape[0]
    print("Complete cases:", complete_cases)

    # Proporción de casos completos
    prop_complete_cases = complete_cases / len(datos)
    print("Proportion of complete cases:", prop_complete_cases)

    # Proporción de valores (celdas) completas
    total_cells = datos.size
    total_complete = datos.count().sum()
    prop_complete = total_complete / total_cells
    print("Proportion of complete cells:", prop_complete)

    # Estadísticas por variable (valores faltantes)
    missing_summary = datos.isnull().sum().reset_index()
    missing_summary.columns = ['Variable', 'Missing Count']
    missing_summary['Missing Proportion'] = missing_summary['Missing Count'] / len(datos)
    print("\nMissing values by column:")
    print(missing_summary)

import pandas as pd


# Crear tablas con frecuencia absoluta y porcentaje
def create_frequency_table(column, column_name):
    """
    Creates a frequency table with both absolute frequency (N) and percentage for a given column in a DataFrame.
    The function also adds a row with total counts and percentage values.


    Args:
    column (pd.Series): The input column (Series) from a DataFrame for which the frequency table will be created.
    column_name (str): The name of the column, which will be used as the header in the resulting frequency table.

    Returns:
    pd.DataFrame: A DataFrame containing the frequency table with the following columns:
        - column_name: The unique values/categories in the input column.
        - N: The absolute frequency of each value/category.
        - Percentage: The percentage of each value/category based on the total count.
    """

    freq_table = column.value_counts(dropna=False).reset_index()
    freq_table.columns = [column_name, "N"]
    freq_table["Percentage"] = (freq_table["N"] / column.size * 100).round(2)
    
    # Agregar fila de totales
    total_row = pd.DataFrame({
        column_name: ["Total"],
        "N": [freq_table["N"].sum()],
        "Percentage": [freq_table["Percentage"].sum()]
    })
    freq_table = pd.concat([freq_table, total_row], ignore_index=True)
    return freq_table

def metrics(y_true, y_pred, nombre):
    """
    Calculate and print performance metrics for a regression model.

    Parameters:
    ----------
    y_true : array-like
        The true values (ground truth) of the target variable.
    y_pred : array-like
        The predicted values of the target variable, generated by the model.
    nombre : str
        The name or description of the model or dataset for which the metrics are calculated.

    Output:
    ------
    Prints the following metrics:
      - R2: The R2 score with 4 decimal places.
      - RMSE: The root mean squared error with 4 decimal places.
    """

    r2 = r2_score(y_true, y_pred)
    rmse = root_mean_squared_error(y_true, y_pred)
    print(f"Métricas para {nombre}:")
    print(f" - R2: {r2:.4f}")
    print(f" - RMSE: {rmse:.4f}")
    print()

import matplotlib.pyplot as plt
import seaborn as sns

def scatter_plot_real_vs_pred(data, real_col, pred_col, dataset_name, figsize=(6, 4), label = ""):
    """
    Generate a scatter plot comparing actual (real) values and predicted values for a given dataset.

    Parameters:
    ----------
    data : pandas.DataFrame
        The dataset containing the real and predicted values.
    real_col : str
        The column name in `data` representing the real (actual) values.
    pred_col : str
        The column name in `data` representing the predicted values.
    dataset_name : str
        The name of the dataset (e.g., "Train", "Test") to include in the plot title.
    figsize : tuple, optional
        The size of the figure, default is (12, 6).

    Functionality:
    -------------
    This function creates a scatter plot where:
    - The x-axis represents the real (actual) values.
    - The y-axis represents the predicted values.
    - A red dashed line is included as a reference, representing perfect predictions (y = x).
    - Alpha is set to 0.7 to adjust point transparency for better visualization.

    Output:
    ------
    Displays the scatter plot for the specified dataset.
    """
    plt.figure(figsize=figsize)

    # Extract real and predicted values
    x = data[real_col]
    y = data[pred_col]

    # Create scatter plot
    sns.scatterplot(x=x, y=y, alpha=0.7, edgecolor=None)
    plt.plot([x.min(), x.max()], [x.min(), x.max()], 'r--', lw=2) 
    # Add labels, title, and grid
    plt.title(f'{dataset_name}: Real vs Predicted Values')
    plt.xlabel('Real Values'+label)
    plt.ylabel('Predicted Values'+label)
    plt.grid()

    # Show plot
    plt.show()

def analyze_residuals(model):
    """
    Perform a residual analysis for a linear regression model fitted using OLS.
    
    This function generates diagnostic plots to evaluate the assumptions of the regression model:
    1. Residuals vs. Fitted values plot.
    2. Histogram of residuals.
    3. Q-Q plot for normality of residuals.
    4. Residuals vs. Index plot.
    
    Parameters:
    -----------
    model : statsmodels.regression.linear_model.RegressionResultsWrapper
        A fitted OLS regression model from statsmodels.
        
    Returns:
    --------
    None
        Displays diagnostic plots for residual analysis.
    """
    # Extract residuals and fitted values
    residuals = model.resid
    fitted_values = model.fittedvalues

    # Create diagnostic plots
    plt.figure(figsize=(6, 5))

    # 1. Residuals vs Fitted values
    plt.subplot(2, 2, 1)
    sns.residplot(x=fitted_values, y=residuals, lowess=True, line_kws={'color': 'red', 'lw': 1})
    plt.title('Residuals vs. Fitted Values')
    plt.xlabel('Fitted Values')
    plt.ylabel('Residuals')

    # 2. Histogram of residuals
    plt.subplot(2, 2, 2)
    sns.histplot(residuals, kde=True, bins=30)
    plt.title('Histogram of Residuals')
    plt.xlabel('Residuals')
    plt.ylabel('Frequency')

    # 3. Q-Q Plot for residual normality
    plt.subplot(2, 2, 3)
    sm.qqplot(residuals, line='45', fit=True, ax=plt.gca())
    plt.title('Q-Q Plot of Residuals')

    # 4. Residuals vs Index
    plt.subplot(2, 2, 4)
    plt.plot(residuals, marker='o', linestyle='', alpha=0.7)
    plt.axhline(y=0, color='red', linestyle='--', lw=1)
    plt.title('Residuals vs. Index')
    plt.xlabel('Index')
    plt.ylabel('Residuals')

    plt.tight_layout()
    plt.show()
